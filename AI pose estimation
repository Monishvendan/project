import cv2
import mediapipe as mp
import math

# Function to calculate angle between 3 points
def calculate_angle(a, b, c):
    """Returns angle at point b in degrees"""
    ba = (a[0]-b[0], a[1]-b[1])
    bc = (c[0]-b[0], c[1]-b[1])
    dot_product = ba[0]*bc[0] + ba[1]*bc[1]
    mag_ba = math.sqrt(ba[0]**2 + ba[1]**2)
    mag_bc = math.sqrt(bc[0]**2 + bc[1]**2)
    if mag_ba * mag_bc == 0:
        return 0
    angle = math.acos(dot_product / (mag_ba * mag_bc))
    return math.degrees(angle)

# Initialize Mediapipe Pose
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(static_image_mode=False,
                    min_detection_confidence=0.5,
                    min_tracking_confidence=0.5)
mp_drawing = mp.solutions.drawing_utils

# Start webcam
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

while True:
    ret, frame = cap.read()
    if not ret:
        break

    frame = cv2.flip(frame, 1)
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = pose.process(rgb_frame)

    posture_text = "No person detected"
    color = (255, 255, 255)

    if results.pose_landmarks:
        mp_drawing.draw_landmarks(
            frame, results.pose_landmarks, mp_pose.POSE_CONNECTIONS,
            mp_drawing.DrawingSpec(color=(0,255,0), thickness=2, circle_radius=2),
            mp_drawing.DrawingSpec(color=(0,0,255), thickness=2)
        )

        h, w, c = frame.shape
        lm = results.pose_landmarks.landmark

        # Keypoints
        left_shoulder = (int(lm[mp_pose.PoseLandmark.LEFT_SHOULDER].x*w),
                         int(lm[mp_pose.PoseLandmark.LEFT_SHOULDER].y*h))
        right_shoulder = (int(lm[mp_pose.PoseLandmark.RIGHT_SHOULDER].x*w),
                          int(lm[mp_pose.PoseLandmark.RIGHT_SHOULDER].y*h))
        neck = ((left_shoulder[0]+right_shoulder[0])//2,
                (left_shoulder[1]+right_shoulder[1])//2)

        left_hip = (int(lm[mp_pose.PoseLandmark.LEFT_HIP].x*w),
                    int(lm[mp_pose.PoseLandmark.LEFT_HIP].y*h))
        right_hip = (int(lm[mp_pose.PoseLandmark.RIGHT_HIP].x*w),
                     int(lm[mp_pose.PoseLandmark.RIGHT_HIP].y*h))
        mid_hip = ((left_hip[0]+right_hip[0])//2,
                   (left_hip[1]+right_hip[1])//2)

        head = (int(lm[mp_pose.PoseLandmark.NOSE].x*w),
                int(lm[mp_pose.PoseLandmark.NOSE].y*h))

        # Draw keypoints
        cv2.circle(frame, head, 5, (0,0,255), -1)
        cv2.circle(frame, neck, 5, (255,0,0), -1)
        cv2.circle(frame, mid_hip, 5, (0,255,255), -1)
        cv2.circle(frame, left_shoulder, 5, (0,255,0), -1)
        cv2.circle(frame, right_shoulder, 5, (0,255,0), -1)

        # Draw alignment lines
        cv2.line(frame, head, neck, (255,255,0), 2)
        cv2.line(frame, neck, mid_hip, (255,255,0), 2)
        cv2.line(frame, left_shoulder, right_shoulder, (0,255,255), 2)

        # --- Posture Metrics ---
        neck_angle = calculate_angle(head, neck, mid_hip)          # Head-Neck-MidHip
        spine_tilt = abs(neck[0] - mid_hip[0])                    # horizontal deviation
        shoulder_tilt = abs(left_shoulder[1] - right_shoulder[1]) # vertical difference
        shoulder_mid_x = (left_shoulder[0] + right_shoulder[0]) // 2
        lean_threshold = 40  # pixels for forward/backward lean

        # --- Thresholds ---
        neck_angle_thresh = 175
        spine_tilt_thresh = 20
        shoulder_tilt_thresh = 20

        # --- Forward/Backward Lean Check ---
        if head[0] > shoulder_mid_x + lean_threshold:
            posture_text = "Bad Posture: Leaning Forward"
            color = (0,0,255)
        elif head[0] < shoulder_mid_x - lean_threshold:
            posture_text = "Bad Posture: Leaning Backward"
            color = (0,0,255)
        # --- Regular Posture Check ---
        elif (neck_angle >= neck_angle_thresh and
              spine_tilt <= spine_tilt_thresh and
              shoulder_tilt <= shoulder_tilt_thresh):
            posture_text = "Good Posture"
            color = (0,255,0)
        else:
            posture_text = "Bad Posture"
            color = (0,0,255)

    # Display posture text
    cv2.putText(frame, posture_text, (30,30), cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2)

    cv2.imshow("Posture Analysis", frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
